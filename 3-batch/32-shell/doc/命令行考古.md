
## lsof命令

`lsof` 这个名字的由来非常直接，它是下面这句话的缩写：

> **List Open Files**

也就是：

```
lsof = list + open + files
```

---

## 🧠 它的含义是什么？

在类 Unix 系统（如 Linux、BSD、macOS）中：

> **“一切皆文件”**（Everything is a file）

* 套接字是文件
* 管道是文件
* 设备是文件
* 普通文件、目录当然也是文件

所以 `lsof` 就是一个 **列出“当前系统中被打开的所有文件”的工具**，本质上也包括：

* 哪些进程打开了哪些文件
* 哪些端口被哪些进程占用（比如 `lsof -i :80`）
* 哪些文件描述符没释放
* 哪些删除了的文件还在被某进程占用

---

## 📜 历史背景

* `lsof` 最早由 **Victor A. Abell** 开发，用于 Unix 系统的进程文件查看。
* 是调试 Linux 下“谁占用了某个资源”问题的重要工具，长期被系统管理员、开发者广泛使用。
* 大多数现代 Unix 系统都默认预装了它，或者可以通过包管理器安装。

---

## 🔍 示例用法

```bash
lsof -i :8080    # 查看 8080 端口被谁占用
lsof /var/log/syslog    # 谁打开了某个文件
lsof +D /usr/lib        # 某目录下所有打开的文件
```

---

## ✅ 总结

| 名称     | 含义                         |
| ------ | -------------------------- |
| `lsof` | **List Open Files**        |
| 作者     | Victor A. Abell            |
| 用途     | 查看哪些文件/端口被哪些进程打开           |
| 适用系统   | Linux、macOS、BSD 等类 Unix 系统 |


## tee命令

`tee` 这个名字其实是来自 **水管系统的三通接头（T 形接头）**，你可以想象下面这个图示：

```
          |
    input |
          v
        tee
       /   \
      /     \
output1   output2
```

---

### 🧠 名字的来源解释：

* 英文中的三通接头叫 **T-junction**，形状就像字母 “T”；
* `tee` 命令在功能上就像一个“T型三通”：它**接收一份输入**，然后**复制成两个输出**，一个送到终端（标准输出），另一个写入文件。

---

### 📌 举个类比

* `cat > file.txt`：水管的水直接进一个桶（只写入文件）
* `tee file.txt`：水管接了一个 T 字头，一路进桶，一路还继续流出来（写入文件 + 显示）

---

所以叫 `tee`，是因为它就像 Unix 的管道中插了一个 T 字分流接头。这是经典 Unix 命令命名中非常形象、工程味十足的一个例子。

----

## uv词缀

“**uv**” 是来自于 **libuv** —— 一个用 C 编写的跨平台异步 I/O 库。它是 Node.js 的底层 I/O 引擎，同时也被 Python 的 `uvloop` 所使用。

---


### 那 libuv 中的 “uv” 是什么意思？

**"uv" 并不是一个缩写，而是源自最初的项目名称——**

> **"Unix Virtual"** 或者更宽泛的 **"Universal"**

不过官方并没有明确给出一个官方缩写含义，很多人将它理解为：

* **Unix Virtual**：因为它最初是为在 Unix 系统上构建异步 I/O 抽象层；
* **Universal**：因为它后来支持了 Windows、macOS、Linux 等多平台，成为跨平台的通用异步库。

---

### 总结一下：

| 名称          | 来源/含义                                          |
| ----------- | ---------------------------------------------- |
| **libuv**   | 一个跨平台的异步 I/O C 库                               |
| **uvloop**  | 基于 libuv 的 Python 异步事件循环                       |
| **uvicorn** | 使用 uvloop 的 ASGI 服务器，“icorn” 灵感来自 unicorn（独角兽） |

也就是说，**“uv” 是一条技术传承线索**：libuv → uvloop → uvicorn。每一层都在把底层的高性能异步 I/O 能力抽象成更易用的上层接口。

----

## Uvicorn命令

“Uvicorn” 这个名字其实是由两部分组成的：

* **“UV”**：来源于 `uvloop`，这是 Uvicorn 底层依赖的高性能事件循环库。`uvloop` 是基于 C 语言的 libuv 实现的，能极大提升 Python 异步程序的性能。
* **“icorn”**：这个部分是一个带有 “独角兽”（unicorn）含义的词根，象征着“独特”、“强大”、“快速”和“现代”。

合起来，“Uvicorn” 就体现了它基于 `uvloop` 技术，致力于打造一个快速、现代且高性能的 ASGI 服务器。名字既有技术内涵，也带点创意和活力感。

简单说，就是“基于 UVLoop 的独角兽服务器”，寓意性能出众且具有创新性的异步服务器。

----

这两个都是在操作系统或编程语言里常见的术语，含义非常接近：

| 缩写      | 全称                            | 含义       | 常见场景                                                           |
| ------- | ----------------------------- | -------- | -------------------------------------------------------------- |
| **pwd** | **print working directory**   | 打印当前工作目录 | Linux / Unix shell 命令（如 `pwd`）                                 |
| **cwd** | **current working directory** | 当前工作目录   | 各种编程语言 API（如 Python 的 `os.getcwd()`、Node.js 的 `process.cwd()`） |

---

### 🔍 区别总结

* **pwd** 是一个命令（动词性质） → 打印当前路径。
  例如：

  ```bash
  $ pwd
  /home/user/projects
  ```

* **cwd** 是一个概念或属性名（名词性质） → 表示“当前工作目录”的值。
  例如：

  ```python
  import os
  print(os.getcwd())  # 输出 /home/user/projects
  ```

---

🧠 小记：

* “working directory” = 当前执行命令或运行程序时所处的文件系统路径。
* 在英文中：

  * **pwd** = “print working directory”（告诉我在哪）
  * **cwd** = “current working directory”（我当前在哪）


